% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stats.R
\name{computeMetricMDS}
\alias{computeMetricMDS}
\title{metric MDS projection of sample}
\usage{
computeMetricMDS(pwDist, nDim = 2, seed = NULL, ...)
}
\arguments{
\item{pwDist}{(\code{nSamples} rows, \code{nSamples} columns),
previously calculated pairwise distances between samples,
must be provided as a full symmetric square matrix, with 0. diagonal}

\item{nDim}{number of dimensions of projection, as input to SMACOF algorithm}

\item{seed}{seed to be set when launching SMACOF algorithm
(e.g. when \code{init=="random"} but not only)}

\item{...}{additional parameters passed to SMACOF algorithm}
}
\value{
a list with six elements:
\itemize{
\item \verb{$pwDist} the initial pair-wise distance (same as input)
\item \verb{$proj} the final configuration, i.e. the projected data matrix
(\code{nSamples} rows, \code{nDim} columns) in \code{nDim} dimensions
\item \verb{$projDist} the distance matrix of projected data
\item \code{stress} the global stress loss function final value
obtained from the SMACOF algorithm
\item \code{spp} the stress per point obtained from the SMACOF algorithm, i.e.
the contribution of each point to the stress loss function
\item \verb{$RSq} R squares, for each d, from 1 to \code{nDim}:
the R square when taking all dims from 1 to d.
}
}
\description{
Multi-dimensional scaling projection of samples,
using a distance matrix as an input.
The MDS algorithm is not the classical MDS
(\code{cmdscale} alike, aka Torgerson's algorithm),
but is the SMACOF algorithm for metric distances that are not
necessarily euclidean.
Note that after the obtention of the projections on the \code{nDim} dimensions,
we always apply svd decomposition to visualize as first axes the ones that
contain the most variance of the projected dataset in \code{nDim} dimensions
}
\examples{

library(CytoPipeline)

data(OMIP021Samples)

# estimate scale transformations 
# and transform the whole OMIP021Samples

transList <- estimateScaleTransforms(
    ff = OMIP021Samples[[1]],
    fluoMethod = "estimateLogicle",
    scatterMethod = "linearQuantile",
    scatterRefMarker = "BV785 - CD3")

OMIP021Trans <- CytoPipeline::applyScaleTransforms(
    OMIP021Samples, 
    transList)
    
ffList <- flowCore::flowSet_to_list(OMIP021Trans)

# As there are only 2 samples in OMIP021Samples dataset,
# we create artificial samples that are random combinations of both samples

for(i in 3:5){
    ffList[[i]] <- 
        CytoPipeline::aggregateAndSample(
            OMIP021Trans,
            seed = 10*i,
            nTotalEvents = 5000)[,1:22]
}

fsNames <- c("Donor1", "Donor2", paste0("Agg",1:3))
names(ffList) <- fsNames

fsAll <- as(ffList,"flowSet")

# calculate all pairwise distances

pwDist <- getPairWiseEMDDist(fsAll, 
                             channels = c("FSC-A", "SSC-A"),
                             verbose = FALSE)

# compute Metric MDS object

mdsObj <- computeMetricMDS(pwDist, seed = 0)

}
