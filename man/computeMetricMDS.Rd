% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stats.R
\name{computeMetricMDS}
\alias{computeMetricMDS}
\title{metric MDS projection of sample}
\usage{
computeMetricMDS(
  pwDist,
  nDim = NULL,
  seed = NULL,
  targetPseudoRSq = 0.99,
  maxDim = 128,
  ...
)
}
\arguments{
\item{pwDist}{(\code{nSamples} rows, \code{nSamples} columns),
previously calculated pairwise distances between samples,
must be provided as a full symmetric square matrix, with 0. diagonal}

\item{nDim}{number of dimensions of projection, as input to SMACOF algorithm
if not provided, will be found iteratively using \code{targetPseudoRSq}}

\item{seed}{seed to be set when launching SMACOF algorithm
(e.g. when \code{init=="random"} but not only)}

\item{targetPseudoRSq}{target pseudo RSquare to be reached
(only used when \code{nDim} is set to NULL)}

\item{maxDim}{in case \code{nDim} is found iteratively,
maximum number of dimensions the search procedure is allowed to explore}

\item{...}{additional parameters passed to SMACOF algorithm}
}
\value{
a list with six elements:
\itemize{
\item \verb{$pwDist} the initial pair-wise distance (same as input)
\item \verb{$proj} the final configuration, i.e. the projected data matrix
(\code{nSamples} rows, \code{nDim} columns) in \code{nDim} dimensions
\item \verb{$projDist} the distance matrix of projected data
\item \code{stress} the global stress loss function final value
obtained from the SMACOF algorithm
\item \code{spp} the stress per point obtained from the SMACOF algorithm, i.e.
the contribution of each point to the stress loss function
\item \verb{$RSq} R squares, for each d, from 1 to \code{nDim}:
the (pseudo) R square when taking all dims from 1 to d.
\item \verb{$GoF} Goodness of fit, for each d, from 1 to \code{nDim}:
the goodness of fit indicator (b/w 0 and 1) when taking all dims from 1 to d.
Note pseudo R square and goodness of fit indicators are essentially the
same indicator, only the definition of total sum of squares differ:
\item for pseudo RSq: TSS is calculated using the mean pairwise distance
as minimum
\item for goodness of fit: TSS is calculated using 0 as minimum
}
}
\description{
Multi-dimensional scaling projection of samples,
using a distance matrix as an input.
The MDS algorithm is not the classical MDS
(\code{cmdscale} alike, aka Torgerson's algorithm),
but is the SMACOF algorithm for metric distances that are not
necessarily euclidean.
After having obtained the projections on the \code{nDim} dimensions,
we always apply svd decomposition to visualize as first axes the ones that
contain the most variance of the projected dataset in \code{nDim} dimensions.
Instead of being provided directly by the user, the \code{nDim} parameter can
otherwise be found iteratively by finding the minimum \code{nDim} parameter that
allows the projection to reach a target pseudo RSquare.
If this is the case, the \code{maxDim} parameter is used to avoid
looking for too big projection spaces.
}
\examples{

library(CytoPipeline)

data(OMIP021Samples)

# estimate scale transformations 
# and transform the whole OMIP021Samples

transList <- estimateScaleTransforms(
    ff = OMIP021Samples[[1]],
    fluoMethod = "estimateLogicle",
    scatterMethod = "linearQuantile",
    scatterRefMarker = "BV785 - CD3")

OMIP021Trans <- CytoPipeline::applyScaleTransforms(
    OMIP021Samples, 
    transList)
    
ffList <- flowCore::flowSet_to_list(OMIP021Trans)

# As there are only 2 samples in OMIP021Samples dataset,
# we create artificial samples that are random combinations of both samples

for(i in 3:5){
    ffList[[i]] <- 
        CytoPipeline::aggregateAndSample(
            OMIP021Trans,
            seed = 10*i,
            nTotalEvents = 5000)[,1:22]
}

fsNames <- c("Donor1", "Donor2", paste0("Agg",1:3))
names(ffList) <- fsNames

fsAll <- as(ffList,"flowSet")

# calculate all pairwise distances

pwDist <- getPairWiseEMDDist(fsAll, 
                             channels = c("FSC-A", "SSC-A"),
                             verbose = FALSE)

# compute Metric MDS object with explicit number of dimensions
mdsObj <- computeMetricMDS(pwDist, nDim = 2, seed = 0)

#' # compute Metric MDS object by reaching a target pseudo RSquare
mdsObj <- computeMetricMDS(pwDist, seed = 0, targetPseudoRSq = 0.999)
mdsObj$nDim # should be 3

}
