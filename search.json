[{"path":"https://uclouvain-cbio.github.io/CytoMDS/articles/CytoMDS.html","id":"installation-and-loading-dependencies","dir":"Articles","previous_headings":"","what":"Installation and loading dependencies","title":"Low Dimensional Projection of Cytometry Samples","text":"install package, start R enter (un-commented): now load packages needed current vignette:","code":"# if (!require(\"BiocManager\", quietly = TRUE)) #     install.packages(\"BiocManager\") #  # BiocManager::install(\"CytoMDS\") suppressPackageStartupMessages(library(HDCytoData)) library(CytoMDS) library(ggplot2) library(patchwork)"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/articles/CytoMDS.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Low Dimensional Projection of Cytometry Samples","text":"CytoMDS package implements low dimensional visualization cytometry samples, order visually assess distances . , turn, can greatly help user identify quality issues like batch effects outlier samples, /check presence potential sample clusters might align experimental design. CytoMDS algorithm combines, one hand, concept Earth Mover’s Distance (EMD) (Orlova et al. 2016), .k.. Wasserstein metric , hand, metric Multi Dimensional Scaling (MDS) algorithm low dimensional projection (Leeuw Mair 2009). Besides projection , package also provides diagnostic tools checking quality MDS projection, well interpreting axes projection (see sections).","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/articles/CytoMDS.html","id":"illustrative-dataset","dir":"Articles","previous_headings":"","what":"Illustrative dataset","title":"Low Dimensional Projection of Cytometry Samples","text":"illustrative dataset used throughout vignette mass cytometry (CyTOF) dataset (Bodenmiller et al. 2012), provided Bioconductor HDCytoData data package (Weber Soneson (2019)). dataset consists 16 paired samples (8 times 2) peripheral blood cells healthy individuals. Among sample pair, one sample - reference - left un-stimulated, sample stimulated B cell receptor / Fc receptor cross-linker (BCR-XL). public dataset known contain strong differential expression signal two conditions (stimulated vs un-stimulated) used recent work benchmark differential analysis algorithms ((Weber et al. 2019)) design mass cytometry data analysis pipelines ((Nowicka et al. 2017)). CytoMDSpackage, current vignette, matrices cytometry events intensities, corresponding one sample, stored flowCore::flowFrame (Ellis et al. 2023) objects. Samples particular cytometry dataset stored flowCore::flowSet object, collection flowFrame’s, .e. one flowFrame per sample. Therefore, load flowSet version BodenMiller2012 dataset, obtained HDCytoData package. regular flowSet’s, experimental design information typically stored phenoData slot, also way CytoMDS expects get input. However, HDCytoData chosen store experimental design information slightly different way, hence need convert data follows: also select channels/markers biologically relevant, .e. cell type cell state markers, store use. discard typical housekeeping markers founds flowFrames like time Cell_length, etc. total, mass cytometry samples contain intensities 24 biologically relevant markers. first step consists scale transforming raw data. Indeed, distances samples make sense scaled transformed signal, distributional differences readable usable downstream analysis. , since dealing mass cytometry samples, use classical arcsinh() transformation 5 co-factor, described elsewhere ((Nowicka et al. 2017)).","code":"BCRXL_fs <- HDCytoData::Bodenmiller_BCR_XL_flowSet() ## see ?HDCytoData and browseVignettes('HDCytoData') for documentation ## loading from cache ## Warning in updateObjectFromSlots(object, ..., verbose = verbose): dropping ## slot(s) 'colnames' from object = 'flowSet' BCRXL_fs ## A flowSet with 16 experiments. ##  ## column names(39): Time Cell_length ... sample_id population_id phenoData <- flowCore::pData(BCRXL_fs) additionalPhenoData <-      keyword(BCRXL_fs[[1]], \"EXPERIMENT_INFO\")$EXPERIMENT_INFO phenoData <- cbind(phenoData, additionalPhenoData)  flowCore::pData(BCRXL_fs) <- phenoData markerInfo <- keyword(BCRXL_fs[[1]], \"MARKER_INFO\")$MARKER_INFO chClass <- markerInfo$marker_class  table(chClass) ## chClass ##  none  type state  ##    11    10    14 chLabels <- markerInfo$channel_name[chClass != \"none\"] (chMarkers <- markerInfo$marker_name[chClass != \"none\"]) ##  [1] \"CD3\"    \"CD45\"   \"pNFkB\"  \"pp38\"   \"CD4\"    \"CD20\"   \"CD33\"   \"pStat5\" ##  [9] \"CD123\"  \"pAkt\"   \"pStat1\" \"pSHP2\"  \"pZap70\" \"pStat3\" \"CD14\"   \"pSlp76\" ## [17] \"pBtk\"   \"pPlcg2\" \"pErk\"   \"pLat\"   \"IgM\"    \"pS6\"    \"HLA-DR\" \"CD7\" trans <- arcsinhTransform(     transformationId=\"ArcsinhTransform\",      a = 0,      b = 1/5,      c = 0)  BCRXL_fs_trans <- transform(     BCRXL_fs,     transformList(chLabels, trans))"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/articles/CytoMDS.html","id":"calculating-distances-between-samples","dir":"Articles","previous_headings":"","what":"Calculating distances between samples","title":"Low Dimensional Projection of Cytometry Samples","text":"can now calculate pairwise Earth Mover’s Distances (EMD) samples dataset. done calling pairwiseEMDDist() method simplest way use method providing directly flowCore::flowSet, containing samples, input parameter. Note , heavy datasets include lot samples, can create memory issues. handle case, CytoMDS provides ways call pairwiseEMDDist() function (see ‘Handling heavy datasets’ section). Using channels argument, possible restrict EMD calculation channels. simply pass input biologically relevant markers selected previous section. return value pairwiseEMDDist function DistSum object. can use .matrix() method convert object matrix, symmetric square matrix, many rows (columns) input samples (extract shown scale-transformed Bodenmiller2012 dataset). One relevant way visualize distance matrix draw histogram pairwise distances, shown plot.","code":"pwDist <- pairwiseEMDDist(     BCRXL_fs_trans,     channels = chMarkers,     verbose = FALSE ) pwDistMatrix <- as.matrix(pwDist) round(pwDistMatrix[1:10, 1:10], 2) ##        1     2     3     4     5     6     7     8     9    10 ## 1   0.00 10.46  4.30 11.18  6.39 12.69  7.11 11.85  5.88 10.13 ## 2  10.46  0.00 10.91  3.16 11.45  6.06 13.17 10.61  9.61  6.08 ## 3   4.30 10.91  0.00 10.72  7.44 13.17  7.47 12.84  5.84 10.00 ## 4  11.18  3.16 10.72  0.00 12.10  5.97 12.66  9.63 10.35  6.72 ## 5   6.39 11.45  7.44 12.10  0.00  9.19  4.45 10.19  5.28  9.96 ## 6  12.69  6.06 13.17  5.97  9.19  0.00 10.56  7.23 11.61  7.74 ## 7   7.11 13.17  7.47 12.66  4.45 10.56  0.00  7.24  8.89 11.87 ## 8  11.85 10.61 12.84  9.63 10.19  7.23  7.24  0.00 14.50 11.68 ## 9   5.88  9.61  5.84 10.35  5.28 11.61  8.89 14.50  0.00  7.10 ## 10 10.13  6.08 10.00  6.72  9.96  7.74 11.87 11.68  7.10  0.00 distVec <- pwDistMatrix[upper.tri(pwDist)] distVecDF <- data.frame(dist = distVec) pHist <- ggplot(distVecDF, mapping = aes(x=dist)) +      geom_histogram(fill = \"darkgrey\", col = \"black\", bins = 15) +      theme_bw() + ggtitle(\"EMD distances for Bodenmiller2012 dataset\") pHist"},{"path":[]},{"path":"https://uclouvain-cbio.github.io/CytoMDS/articles/CytoMDS.html","id":"calculating-the-mds-projection","dir":"Articles","previous_headings":"Metric Multidimensional scaling","what":"Calculating the MDS projection","title":"Low Dimensional Projection of Cytometry Samples","text":"pairwise distance matrix calculated, computing Multi Dimensional Scaling (MDS) projection done calling computeMetricMDS() function. simplest form, distance DistSum object (distance matrix) needs passed function. case, number dimensions use MDS automatically set order reach specific value projection quality indicator, .e. target pseudo R square, turn set default 0.95 (see Quality projection - diagnostic tools section). Note Smacof algorithm (Leeuw Mair 2009), used compute MDS projection, stochastic, sensitive ‘seed’ used. Therefore, cases reproducible results one run another required, advised set seed argument fixed value. returned value computeMetricMDS() function object MDS class. object can queried get e.g. number dimensions effectively used, obtained pseudo RSquare, shown following code chunk:","code":"mdsObj <- computeMetricMDS(pwDist, seed = 0) show(mdsObj) ## MDS object containing MDS projection (using Smacof algorithm)  data: ## Nb of dimensions:  4  ## Nb of points:  16  ## Stress:  0.040668  ## Pseudo RSquare:  0.981489  ## Goodness of fit:  0.998346"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/articles/CytoMDS.html","id":"plotting-the-mds-projection","dir":"Articles","previous_headings":"Metric Multidimensional scaling","what":"Plotting the MDS projection","title":"Low Dimensional Projection of Cytometry Samples","text":"Plotting obtained MDS projection done using ggplotSampleMDS(). phenoData parameter passed, , default, numbers used labels, samples represented black dots.  However, providing ‘phenoData’ dataframe ggplotSampleMDS() function, corresponding variables can used highlighting sample points different colours /shapes. , previous plot enhanced red blue colours, distinguishing samples two conditions. Also, added meaningful labels data point, corresponding patient id’s. plot, one can clearly see clear separation samples two different conditions. 2 sample groups different along x axis, corresponds first projection direction, explaining 46.69 % variability contained MDS projection 4 dimensions (indicated subtitle). clear separation 2 condition clusters highlights strong biological signal differentiating two groups samples. vignette, shall try assign user interpretation x axis direction (see ‘Aid interpreting projection axes’ section).  Given 4 dimensions used metric MDS algorithm, user can visualize MDS projection using combination two axes, example axes 2 3, 3 4, :  plots reveal two important findings: 1. Dots 2 samples groups well-mixed views, showing biological difference two sample groups mainly concentrated along first projection axis. 2. Dots corresponding samples patient id time close . conclude variability contained axes 2, 3 4 mostly represent biological variation different individuals, (much less) effect stimulation.","code":"ggplotSampleMDS(mdsObj) p12 <- ggplotSampleMDS(     mdsObj,     pData = phenoData,     projectionAxes = c(1,2),     pDataForColour = \"group_id\",     pDataForLabel = \"patient_id\" ) p12 p23 <- ggplotSampleMDS(     mdsObj,     pData = phenoData,     projectionAxes = c(2,3),     pDataForColour = \"group_id\",     pDataForLabel = \"patient_id\" )  p34 <- ggplotSampleMDS(     mdsObj,     pData = phenoData,     projectionAxes = c(3,4),     pDataForColour = \"group_id\",     pDataForLabel = \"patient_id\" ) p23 / p34"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/articles/CytoMDS.html","id":"quality-of-projection---diagnostic-tools","dir":"Articles","previous_headings":"Metric Multidimensional scaling","what":"Quality of projection - diagnostic tools","title":"Low Dimensional Projection of Cytometry Samples","text":"order able trust projected distances obtained CytoMDS plots, couple projection quality indicators can verified : - pseudo RSquare indicator shows percentage variability contained pairwise distance matrix actually contained low dimensional MDS projection. analog statistical RSquare linear regression model, .e. closer one pseudo RSquare , better. Note pseudo RSquare refers variability contained dimensions MDS projection, two plotted axes. - nDim number dimensions projection needed obtain corresponding pseudo RSquare (4 dimensions). - percentage variation captured along axis (coordinates), interpreted respect total variability captured MDS projection, total variability. example, previous section, MDS projection using 4 dimensions able capture 98.15% (pseudo RSquare) initial variability contained calculated pairwise distance matrix. 98.15%, 46.69% turn captured axis 1, 29.95% captured axis 2, 15.38% captured axis 3 7.99% captured axis 4. Another useful projection quality diagnostic tool Shepard diagram. diagram, dot represents single distance sample pair, x coordinate original (high dimensional) distance two samples, y coordinate projected low dimensional distance, obtained MDS projection algorithm. Shepard diagram, ideal situation dots located straight line passing (0,0) (1,1) points. diagram, one can notice points near ideal straight line, hence distance projections can trusted.","code":"ggplotSampleMDSShepard(mdsObj)"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/articles/CytoMDS.html","id":"additional-options-for-the-mds-projection","dir":"Articles","previous_headings":"Metric Multidimensional scaling","what":"Additional options for the MDS projection","title":"Low Dimensional Projection of Cytometry Samples","text":"section, describe couple additional options available user calculating MDS projection using computeMetricMDS(). First, instead letting algorithm choose number dimensions, also possible assign explicitly, example 2, :  Note obtained projection 2 axes, although similar, exactly one obtained visualizing first two axis MDS projection obtained , 4 dimensions. Actually, feature Metric MDS projection, although might appear bit counter-intuitive first. Second, also possible adjust number dimensions indirectly, setting explicit pseudo Rsquare target. case algorithm increase number dimensions reaching required quality target, instead default 0.95 target. example shows obtain pseudo R Square least 0.99. result, needed number dimensions now 6, instead 4.  corresponding Shepard diagram obtained , showing dots even concentrated around ideal straight line, :","code":"mdsObj2 <- CytoMDS::computeMetricMDS(pwDist, seed = 0, nDim = 2)  ggplotSampleMDS(mdsObj2,                  pData = phenoData,                  projectionAxes = c(1,2),                  pDataForColour = \"group_id\",                  pDataForLabel = \"patient_id\",                  flipYAxis = TRUE) mdsObj3 <- CytoMDS::computeMetricMDS(pwDist, seed = 0, targetPseudoRSq = 0.99) ggplotSampleMDS(mdsObj3,                  pData = phenoData,                  projectionAxes = c(1,2),                  pDataForColour = \"group_id\",                  pDataForLabel = \"patient_id\") ggplotSampleMDSShepard(mdsObj3)"},{"path":[]},{"path":"https://uclouvain-cbio.github.io/CytoMDS/articles/CytoMDS.html","id":"bi-plots","dir":"Articles","previous_headings":"Metric Multidimensional scaling > Aid to interpreting projection axes","what":"Bi-plots","title":"Low Dimensional Projection of Cytometry Samples","text":"MDS projections, possible (try ) associate axis directions specific sample characteristics. idea calculate correlation well chosen sample statistics w.r.t. axes projection, correlations can represented correlation circle, overlaid projection plot. plot set-called ‘bi-plot’. order produce bi=plot, user first needs calculate chosen statistics interest want assess association axis directions. Typically, one chooses channel specific statistics, like e.g. mean, standard deviation, quantile might interest. However, statistics can calculated sample can used (number events,…) , provide example user overlays median different channels, bi-plot MDS projection axes 1 2. bi-plot, arrow - representing channel median - located coordinates equal respective Pearson correlation w.r.t. two axis. , one can identify x axis strong positive correlation median markers ‘CD4’, ‘CD33’, ‘CD20’, ‘pNFkB’, ‘pp38’, ‘pBtk’ ‘pSlp76’, strong negative correlation median marker ‘HLA-DR’. y axis strong negative correlation median number markers: ‘CD123’, ‘pStat1’, ‘pStat5’, ‘pSHP2’, ‘pAkt’, ‘pZap70’ ‘pPlcg2’.  Note , bi-plots, arrows length greater equal specific threshold (default set 0.8) represented, order overwhelm plot arrows, especially dataset uses high dimensional panel. however possible adjust threshold explicitly setting arrowThreshold argument. example, plot, threshold set set 0.6, showing, example, x axis also strongly negatively correlated median ‘pS6’ ‘CD7’ markers.  terms biological interpretation, since x axis direction along clear separation stimulated (reference) un-stimulated samples, biplot suggests channels median appears strongly correlated x axis, also show visible distributional difference two sample groups. order check , can use ggplotMarginalDensities method provided CytoMDS package, follows: indeed, can notice Reference samples (red) tend show higher intensity values markers ‘pNFkB’, ‘pp38’, ‘CD4’, ‘CD20’, ‘CD33’, ‘pSlp76’, ‘pBtk’, BCR-XL stimulated samples (blue) tend show higher internsity valeus markers ‘pS6’, ‘HLA-DR’ ‘CD7’. markers identified strongly (resp. positively negatively) correlated x axis bi-plot.","code":"medians <- channelSummaryStats(BCRXL_fs_trans,                                 channels = chLabels,                                 statFUNs = median) ggplotSampleMDS(mdsObj,                 pData = phenoData,                 pDataForColour = \"group_id\",                 displayPointLabels = FALSE,                 displayArrowLabels = TRUE,                 repelArrowLabels = TRUE,                 biplot = TRUE,                 extVariables = medians) ggplotSampleMDS(mdsObj,                 pData = phenoData,                 pDataForColour = \"group_id\",                 displayPointLabels = FALSE,                 displayArrowLabels = TRUE,                 repelArrowLabels = TRUE,                 biplot = TRUE,                 extVariables = medians,                 arrowThreshold = 0.6) ggplotMarginalDensities(     BCRXL_fs_trans,      channels = chLabels,     pDataForColour = \"group_id\",     pDataForGroup = \"sample_id\")"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/articles/CytoMDS.html","id":"bi-plot-wrapping","dir":"Articles","previous_headings":"Metric Multidimensional scaling > Aid to interpreting projection axes","what":"Bi-plot wrapping","title":"Low Dimensional Projection of Cytometry Samples","text":"Instead drawing one single bi-plot related specific type statistics, example channel medians , can also try associate axes different channel statistics . next plot, draw bi-plots channel medians, 25% 75% quantiles, standard deviations . ‘facets-alike’ bi-plot, bi-plot wrapping, obtained thanks ggplotSampleMDSWrapBiplots() function, internally calls ggplotSampleMDS() function several times, arrange obtained outputs single plot.  Sometimes, case plots , high number channel statistics strongly correlated bi-plot axes, plot hardly readable, due many arrows displayed. case, advised generate series bi-plots, part channel statistics, order better identify strongly correlated ones. One example provided , showing correlation axes standard deviation channel:","code":"statFUNs = c(\"median\" = stats::median,              \"Q25\" = function(x, na.rm) {                  stats::quantile(x, probs = 0.25)              },              \"Q75\" = function(x, na.rm) {                  stats::quantile(x, probs = 0.75)              },              \"standard deviation\" = stats::sd) chStats <- channelSummaryStats(BCRXL_fs_trans,                                channels = chLabels,                                 statFUNs = statFUNs) ggplotSampleMDSWrapBiplots(     mdsObj,     extVariableList = chStats,     ncol = 2,     pData = phenoData,     pDataForColour = \"group_id\",     displayPointLabels = FALSE,     displayArrowLabels = TRUE,     repelArrowLabels = TRUE,     displayLegend = FALSE) stdDevs <- list(     \"std dev of channels 1 to 6\" = chStats[[\"standard deviation\"]][,1:6],     \"std dev of channels 7 to 12\" = chStats[[\"standard deviation\"]][,7:12],     \"std dev of channels 13 to 18\" = chStats[[\"standard deviation\"]][,13:18],     \"std dev of channels 19 to 24\" = chStats[[\"standard deviation\"]][,19:24] )  ggplotSampleMDSWrapBiplots(     mdsObj,     ncol = 2,     extVariableList = stdDevs,     pData = phenoData,     pDataForColour = \"group_id\",     displayPointLabels = FALSE,     displayArrowLabels = TRUE,     repelArrowLabels = TRUE)"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/articles/CytoMDS.html","id":"handling-large-datasets","dir":"Articles","previous_headings":"","what":"Handling large datasets","title":"Low Dimensional Projection of Cytometry Samples","text":"Computing Earth Mover’s Distances sample pairs large datasets (e.g. hundreds samples), heavy computational task. First, loading whole data set flowCore::flowSet() RAM , might possible due size. Second, calculating matrix pairwise distances, computational complexity O(N2), can lead long computation times large datasets. Therefore, CytoMDS package provides several mechanisms allowing mitigate issues.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/articles/CytoMDS.html","id":"loading-flow-frames-dynamically-during-distance-matrix-computation","dir":"Articles","previous_headings":"Handling large datasets","what":"Loading flow frames dynamically during distance matrix computation","title":"Low Dimensional Projection of Cytometry Samples","text":"order able handle datasets greater size available computer RAM, pairwiseEMDDist() function allows alternative input mode, : - input samples provided directly via flowCore::flowSet, list expression matrices, - user provides nb samples, user-written expression matrix loading function called dynamically load ith sample - expression matrix - upon request, optionally additional arguments. Typically, expression matrix loading function provided user shall describe read ith sample disk.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/articles/CytoMDS.html","id":"using-biocparallel-to-parallelize-distance-matrix-computation","dir":"Articles","previous_headings":"Handling large datasets","what":"Using BiocParallel to parallelize distance matrix computation","title":"Low Dimensional Projection of Cytometry Samples","text":"Also, CytoMDS pairwise distance calculation supports parallelization distance matrix computation, use BiocParallel package. parallelization used, calculation engine automatically create worker tasks corresponding calculation blocks distance matrix. , provide example BodenMiller2012 dataset. Note example illustrative purpose , fact dataset small enough fully reside memory require parallelization distance calculation. case ‘--fly’ expression matrices -memory loading required, advise, preliminary step, store samples, previously scale transformed, disk. temporary directory. , pairwiseEMDDist() method can called, now specifying number samples, expression matrix loading function, BiocParallel::SnowParam() backbone parallelization computations. obtained distances - shown histogram - exactly .","code":"storageLocation <- suppressMessages(base::tempdir())  nSample <- length(BCRXL_fs_trans) fileNames <- file.path(     storageLocation,     paste0(\"BodenMiller2012_TransformedSample\",             sprintf(\"%02d.rds\", seq_len(nSample))))  for (i in seq_len(nSample)) {     saveRDS(BCRXL_fs_trans[[i]],             file = fileNames[i]) } bp <- BiocParallel::SnowParam(     stop.on.error = FALSE,     progressbar = TRUE) pwDistLast <- suppressWarnings(pairwiseEMDDist(     x = nSample,     channels = chMarkers,     loadExprMatrixFUN  = function(exprMatrixIndex, files, channels, markers){         ff <- readRDS(file = files[exprMatrixIndex ])         exprMat <- flowCore::exprs(ff)[, channels, drop = FALSE]         colnames(exprMat) <- markers         exprMat     },     loadExprMatrixFUNArgs = list(         files = fileNames,          channels = chLabels,         markers = chMarkers),     BPPARAM = bp)) ##   |                                                                              |                                                                      |   0%  |                                                                              |==================                                                    |  25%  |                                                                              |===================================                                   |  50%  |                                                                              |====================================================                  |  75%  |                                                                              |======================================================================| 100% ##  ##   |                                                                              |                                                                      |   0%  |                                                                              |============                                                          |  17%  |                                                                              |=======================                                               |  33%  |                                                                              |===================================                                   |  50%  |                                                                              |===============================================                       |  67%  |                                                                              |==========================================================            |  83%  |                                                                              |======================================================================| 100% pwDistLastMat <- as.matrix(pwDistLast) distVecLast <- pwDistLastMat[upper.tri(pwDistLastMat)] distVecDFLast <- data.frame(dist = distVecLast) pHistLast <- ggplot(distVecDFLast, mapping = aes(x=dist)) +     geom_histogram(fill = \"darkgrey\", col = \"black\", bins = 15) +     theme_bw() +      ggtitle(         \"EMD distances for Bodenmiller2012 dataset\",          subtitle =  \"on the fly memory loading and parallel computation\") pHistLast"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/articles/CytoMDS.html","id":"expression-matrices-as-input-instead-of-flowframes","dir":"Articles","previous_headings":"","what":"Expression matrices as input instead of flowFrames","title":"Low Dimensional Projection of Cytometry Samples","text":"Standard use CytoMDS involves providing cytometry sample data, contained flowCore standard cytometry data structures (flowSet flowFrame) input Earth Mover’s distance calculation. However, CytoMDS can also accept generic input data, list expression matrices, stored standard R matrices. instance, allows using CytoMDS visualizations type data cytometry, long sample can represented matrix number rows (cells), fixed columns/features (markers). illustrating toy example randomly simulated data. Let us first simulate 10 samples 1,000 rows 10 features. Samples split 2 groups: conditionA conditionB increased expression std deviation 3 features conditionB, compared conditionA. can now generate pairwise sample distance matrix, based previously simulated matrix list, show corresponding histogram:  generated pairwise distance matrix, can now proceed CytoMDS workflow, previous examples:","code":"nSample <- 10 conditions <- factor(c(rep(\"conditionA\", 5), rep(\"conditionB\", 5))) nRow <- 1000 nFeat <- 10 nDiffFeat <- 3 diffFeats = c(2, 3, 9) stdDevFactor = 1.5  exprMatrixList <- mapply(     seq(nSample),     conditions,     FUN = function(i, condition) {         exprMatrix <- matrix(rnorm(nRow*nFeat), nrow = nRow)         if (condition == \"conditionB\") {             exprMatrix[, diffFeats] <- exprMatrix[, diffFeats] * stdDevFactor         }         colnames(exprMatrix) <- paste0(\"Feat\", seq(nFeat))         exprMatrix     },     SIMPLIFY = FALSE )  names(exprMatrixList) <- paste0(\"sample\", seq(nSample)) pwDistExpr <-  pairwiseEMDDist(     exprMatrixList ) pwDistExprmat <- as.matrix(pwDistExpr) distVecExpr <- pwDistExprmat[upper.tri(pwDistExprmat)] distVecDFExpr <- data.frame(dist = distVecExpr) pHistExpr <- ggplot(distVecDFExpr, mapping = aes(x=dist)) +     geom_histogram(fill = \"darkgrey\", col = \"black\", bins = 15) +     theme_bw() +      ggtitle(         \"EMD distances for simulated expression matrices\") pHistExpr mdsObjExpr <- computeMetricMDS(pwDistExpr, seed = 0) show(mdsObjExpr) ## MDS object containing MDS projection (using Smacof algorithm)  data: ## Nb of dimensions:  3  ## Nb of points:  10  ## Stress:  0.065625  ## Pseudo RSquare:  0.972289  ## Goodness of fit:  0.995693 phenoDataExpr <- data.frame(sampleId = seq(nSample), cond = conditions) p12 <- ggplotSampleMDS(     mdsObjExpr,     pData = phenoDataExpr,     projectionAxes = c(1,2),     pDataForColour = \"cond\",     pDataForLabel = \"sampleId\" ) p12 statFunctions <- list(mean = base::mean,                       std_dev = stats::sd) chStatsExpr <- channelSummaryStats(exprMatrixList,                                    statFUNs  = statFunctions) p <- CytoMDS::ggplotSampleMDSWrapBiplots(     mdsObj = mdsObjExpr,     extVariableList = chStatsExpr,     pData = phenoDataExpr,     projectionAxes = c(1,2),     pDataForColour = \"cond\",     displayPointLabels = FALSE,     repelArrowLabels = TRUE,     ncol = 2,     arrowThreshold = 0.9 ) p"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/articles/CytoMDS.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Low Dimensional Projection of Cytometry Samples","text":"","code":"## R Under development (unstable) (2024-12-04 r87420) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.1 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] patchwork_1.3.0             ggplot2_3.5.1               ##  [3] CytoMDS_1.3.3               HDCytoData_1.27.0           ##  [5] flowCore_2.19.0             SummarizedExperiment_1.37.0 ##  [7] Biobase_2.67.0              GenomicRanges_1.59.1        ##  [9] GenomeInfoDb_1.43.2         IRanges_2.41.2              ## [11] S4Vectors_0.45.2            MatrixGenerics_1.19.0       ## [13] matrixStats_1.4.1           ExperimentHub_2.15.0        ## [15] AnnotationHub_3.15.0        BiocFileCache_2.15.0        ## [17] dbplyr_2.5.0                BiocGenerics_0.53.3         ## [19] generics_0.1.3              BiocStyle_2.35.0            ##  ## loaded via a namespace (and not attached): ##   [1] splines_4.5.0           filelock_1.0.3          tibble_3.2.1            ##   [4] polyclip_1.10-7         graph_1.85.0            XML_3.99-0.17           ##   [7] rpart_4.1.23            lifecycle_1.0.4         doParallel_1.0.17       ##  [10] flowWorkspace_4.19.0    lattice_0.22-6          MASS_7.3-61             ##  [13] backports_1.5.0         magrittr_2.0.3          Hmisc_5.2-1             ##  [16] sass_0.4.9              rmarkdown_2.29          jquerylib_0.1.4         ##  [19] yaml_2.3.10             plotrix_3.8-4           DBI_1.2.3               ##  [22] minqa_1.2.8             RColorBrewer_1.1-3      abind_1.4-8             ##  [25] zlibbioc_1.53.0         ggcyto_1.35.0           purrr_1.0.2             ##  [28] nnet_7.3-19             pracma_2.4.4            tweenr_2.0.3            ##  [31] rappdirs_0.3.3          transport_0.15-4        GenomeInfoDbData_1.2.13 ##  [34] ggrepel_0.9.6           gdata_3.0.1             ellipse_0.5.0           ##  [37] pkgdown_2.1.1.9000      codetools_0.2-20        DelayedArray_0.33.3     ##  [40] ggforce_0.4.2           tidyselect_1.2.1        shape_1.4.6.1           ##  [43] UCSC.utils_1.3.0        farver_2.1.2            lme4_1.1-35.5           ##  [46] base64enc_0.1-3         jsonlite_1.8.9          e1071_1.7-16            ##  [49] mitml_0.4-5             Formula_1.2-5           survival_3.7-0          ##  [52] iterators_1.0.14        systemfonts_1.1.0       foreach_1.5.2           ##  [55] tools_4.5.0             ragg_1.3.3              snow_0.4-4              ##  [58] Rcpp_1.0.13-1           glue_1.8.0              gridExtra_2.3           ##  [61] pan_1.9                 SparseArray_1.7.2       xfun_0.49               ##  [64] dplyr_1.1.4             withr_3.0.2             BiocManager_1.30.25     ##  [67] fastmap_1.2.0           boot_1.3-31             fansi_1.0.6             ##  [70] digest_0.6.37           R6_2.5.1                mime_0.12               ##  [73] mice_3.17.0             textshaping_0.4.1       colorspace_2.1-1        ##  [76] gtools_3.9.5            RSQLite_2.3.9           weights_1.0.4           ##  [79] utf8_1.2.4              tidyr_1.3.1             hexbin_1.28.5           ##  [82] data.table_1.16.4       class_7.3-22            httr_1.4.7              ##  [85] htmlwidgets_1.6.4       S4Arrays_1.7.1          pkgconfig_2.0.3         ##  [88] gtable_0.3.6            blob_1.2.4              RProtoBufLib_2.19.0     ##  [91] XVector_0.47.0          htmltools_0.5.8.1       bookdown_0.41           ##  [94] scales_1.3.0            png_0.1-8               wordcloud_2.6           ##  [97] knitr_1.49              rstudioapi_0.17.1       reshape2_1.4.4          ## [100] checkmate_2.3.2         nlme_3.1-166            curl_6.0.1              ## [103] nloptr_2.1.1            proxy_0.4-27            cachem_1.1.0            ## [106] stringr_1.5.1           BiocVersion_3.21.1      parallel_4.5.0          ## [109] foreign_0.8-87          AnnotationDbi_1.69.0    desc_1.4.3              ## [112] pillar_1.9.0            grid_4.5.0              vctrs_0.6.5             ## [115] cytolib_2.19.0          jomo_2.7-6              cluster_2.1.7           ## [118] htmlTable_2.4.3         Rgraphviz_2.51.0        evaluate_1.0.1          ## [121] cli_3.6.3               compiler_4.5.0          rlang_1.1.4             ## [124] crayon_1.5.3            smacof_2.1-7            ncdfFlow_2.53.0         ## [127] labeling_0.4.3          plyr_1.8.9              fs_1.6.5                ## [130] stringi_1.8.4           BiocParallel_1.41.0     nnls_1.6                ## [133] munsell_0.5.1           Biostrings_2.75.1       glmnet_4.1-8            ## [136] Matrix_1.7-1            bit64_4.5.2             CytoPipeline_1.7.0      ## [139] KEGGREST_1.47.0         broom_1.0.7             memoise_2.0.1           ## [142] bslib_0.8.0             bit_4.5.0.1             polynom_1.4-1"},{"path":[]},{"path":"https://uclouvain-cbio.github.io/CytoMDS/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Philippe Hauchamps. Author, maintainer. Laurent Gatto. Author. Dan Lin. Contributor.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hauchamps, Philippe, Delandre, Simon, Temmerman, T S, Lin, Dan, Gatto, Laurent (2024). “Visual quality control CytoMDS, Bioconductor package low dimensional representation cytometry sample distances.” bioRxiv, 2024.07.01.601465.","code":"@Article{,   title = {Visual quality control with {CytoMDS}, a Bioconductor package for               low dimensional representation of cytometry sample distances},   author = {{Hauchamps} and {Philippe} and {Delandre} and {Simon} and {Temmerman} and Stephane T and {Lin} and {Dan} and {Gatto} and {Laurent}},   journal = {bioRxiv},   pages = {2024.07.01.601465},   month = {7},   year = {2024},   language = {en}, }"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/index.html","id":"low-dimensional-projection-of-cytometry-samples","dir":"","previous_headings":"","what":"Low Dimensions projection of cytometry samples","title":"Low Dimensions projection of cytometry samples","text":"CytoMDS package implements low dimensional visualization set cytometry samples, order visually assess ‘distances’ . , turn, can greatly help user identify quality issues like batch effects outlier samples, /check presence potential sample clusters might align experimental design. CytoMDS algorithm combines, one hand, concept Earth Mover’s Distance (EMD), .k.. Wasserstein metric , hand, Multi Dimensional Scaling (MDS) algorithm low dimensional projection. Also, package provides diagnostic tools checking quality MDS projection, well tools help interpretation axes projection.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Low Dimensions projection of cytometry samples","text":"CytoMDS code provided GPL license version 3.0 higher. documentation, including manual pages vignettes, distributed CC -SA 4.0 license.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Low Dimensions projection of cytometry samples","text":"use CytoMDS research, please use following citation: Hauchamps, Philippe, Simon Delandre, Stephane T. Temmerman, Dan Lin, Laurent Gatto. 2024. “Visual Quality Control CytoMDS, Bioconductor Package Low Dimensional Representation Cytometry Sample Distances.” bioRxiv. https://doi.org/10.1101/2024.07.01.601465. run citation(\"CytoMDS\") get bibtex entry.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/CytoMDS-package.html","id":null,"dir":"Reference","previous_headings":"","what":"CytoMDS: Low Dimensions projection of cytometry samples — CytoMDS-package","title":"CytoMDS: Low Dimensions projection of cytometry samples — CytoMDS-package","text":"package implements low dimensional visualization set cytometry samples, order visually assess 'distances' . , turn, can greatly help user identify quality issues like batch effects outlier samples, /check presence potential sample clusters might align exeprimental design. CytoMDS algorithm combines, one hand, concept Earth Mover's Distance (EMD), .k.. Wasserstein metric , hand, Multi Dimensional Scaling (MDS) algorithm low dimensional projection. Also, package provides diagnostic tools checking quality MDS projection, well tools help interpretation axes projection.","code":""},{"path":[]},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/CytoMDS-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"CytoMDS: Low Dimensions projection of cytometry samples — CytoMDS-package","text":"Maintainer: Philippe Hauchamps philippe.hauchamps@uclouvain.(ORCID) Authors: Laurent Gatto laurent.gatto@uclouvain.(ORCID) contributors: Dan Lin dan.8.lin@gsk.com [contributor]","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/DistSum-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DistSum class — DistSum","title":"DistSum class — DistSum","text":"Class representing pairwise distances multiple multidimensional distributions, distance calculated sum marginal distribution distances.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/DistSum-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DistSum class — DistSum","text":"","code":"# S4 method for class 'DistSum' show(object)  # S4 method for class 'matrix' DistSum(object)  # S4 method for class 'list' DistSum(object)  # S4 method for class 'DistSum' dim(x)  # S4 method for class 'DistSum' dimnames(x)  # S4 method for class 'DistSum,list' dimnames(x) <- value  # S4 method for class 'DistSum,ANY' dimnames(x) <- value  # S4 method for class 'DistSum' ncol(x)  # S4 method for class 'DistSum' colnames(x)  # S4 method for class 'DistSum' colnames(x) <- value  # S4 method for class 'DistSum' nrow(x)  # S4 method for class 'DistSum' rownames(x)  # S4 method for class 'DistSum' rownames(x) <- value  nFeatures(x)  # S4 method for class 'DistSum' featureNames(object)  # S4 method for class 'DistSum' featureNames(object) <- value  # S4 method for class 'DistSum,ANY,ANY,ANY' x[i, j, ..., drop = TRUE]  # S4 method for class 'DistSum,ANY,ANY,missing' x[i, j, ..., drop = TRUE]  # S4 method for class 'DistSum,ANY,missing,ANY' x[i, j, ..., drop = TRUE]  # S4 method for class 'DistSum,ANY,missing,missing' x[i, j, ..., drop = TRUE]  # S4 method for class 'DistSum' as.matrix(x, whichFeatures = NULL)  distByFeature(distObj)"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/DistSum-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DistSum class — DistSum","text":"object DistSum object x DistSum object value new feature names assigned array index j column index ... arguments (used) drop supported (set FALSE) whichFeatures either array feature names, array feature indices, NULL NULL, full distance (features) returned NULL, whichFeatures array contain duplicates distObj DistSum object","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/DistSum-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"DistSum class — DistSum","text":"nothing data.frame, 3 columns: featureName : self explainatory distanceContrib : unidimensional distance along corresponding feature percentage : percentage feture distance w.r.t. full distance","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/DistSum-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DistSum class — DistSum","text":"pwDistPerFeature list matrix objects storing contribution feature (dimension) multidimensional distributions full pairwise distance matrix. Note matrices necessarily square symmetric matrices, DistSum occasionally used store given block bigger distance matrix.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/DistSum-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DistSum class — DistSum","text":"","code":"# create a dummy distance matrix  # to do this we use `nPoints` points  # in an euclidian space of `nFeat` dimensions nPoints <- 5 nFeat <- 7 M <- matrix(data = rnorm(nPoints * nFeat), ncol = nFeat) rownames(M) <- paste0(\"point\", 1:nPoints) colnames(M) <- paste0(\"feat\", 1:nFeat)  DList <- lapply(colnames(M), FUN = function(colName) {     D <- as.matrix(dist(         M[, colName, drop = FALSE]))     D })  D <- Reduce(x = DList, f = function(A, B) A + B)  names(DList) <- colnames(M)  # Example of creating of a DistSum object based on the full distance matrix distObj1 <- DistSum(D) show(distObj1) #> `DistSum` object containing pairwise distances between distributions #>  and their decomposition as a sum of feature contributions #> Matrix dimensions:  5 5  #> Nb of features:  1  #> Feature names:   #> Full distance matrix:  #>          point1   point2    point3    point4    point5 #> point1 0.000000 8.851750  9.407961  7.957533  9.126406 #> point2 8.851750 0.000000  8.827115  7.094430  4.580522 #> point3 9.407961 8.827115  0.000000 10.959452 10.329413 #> point4 7.957533 7.094430 10.959452  0.000000  7.613967 #> point5 9.126406 4.580522 10.329413  7.613967  0.000000  # Example of creation of a DistSum object based on a list of matrices # representing the additive contribution of each feature distObj2 <- DistSum(DList)  show(distObj2) #> `DistSum` object containing pairwise distances between distributions #>  and their decomposition as a sum of feature contributions #> Matrix dimensions:  5 5  #> Nb of features:  7  #> Feature names:  feat1 feat2 feat3 feat4 feat5 feat6 feat7  #> Full distance matrix:  #>          point1   point2    point3    point4    point5 #> point1 0.000000 8.851750  9.407961  7.957533  9.126406 #> point2 8.851750 0.000000  8.827115  7.094430  4.580522 #> point3 9.407961 8.827115  0.000000 10.959452 10.329413 #> point4 7.957533 7.094430 10.959452  0.000000  7.613967 #> point5 9.126406 4.580522 10.329413  7.613967  0.000000  # getting dimensions myDim <- dim(distObj2) # c(nPoints, nPoints) ncols <- ncol(distObj2) # nPoints nrows <- nrow(distObj2) # nPoints nFeats <- nFeatures(distObj2) # nFeat myFeatNames <- featureNames(distObj2) # paste0(\"feat\", 1:nFeat) myRowNames <- rownames(distObj2) # paste0(\"point\", 1:nPoints) myRowNames <- colnames(distObj2) # paste0(\"point\", 1:nPoints)  # get full distance matrix dd <- as.matrix(distObj2)  # get partial distance matrix for feature 1 dd1 <- as.matrix(distObj2, whichFeatures = 1)  # same thing, using feature name dd1bis <- as.matrix(distObj2, whichFeatures = \"feat1\")  # getting partial distance for feature 1 & 2  ddPart <- as.matrix(distObj2, whichFeatures = colnames(M)[1:2])  # getting distance by feature DF <- distByFeature(distObj2)"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/EMDDist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Earth Mover's distance between two samples — EMDDist","title":"Calculate Earth Mover's distance between two samples — EMDDist","text":"Calculate Earth Mover's distance two samples","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/EMDDist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Earth Mover's distance between two samples — EMDDist","text":"","code":"EMDDist(   x1,   x2,   channels = NULL,   binSize = 0.05,   minRange = -10,   maxRange = 10,   returnAll = FALSE )"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/EMDDist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Earth Mover's distance between two samples — EMDDist","text":"x1 can either flowCore::flowFrame, expression matrix x2 can either flowCore::flowFrame, expression matrix channels channels (integer index(ices) character(s)): character vector, can refer either channel names, marker names x1 x2 provided flowCore::flowFrame numeric vector, refers indexes channels x1 NULL : x1 x2 provided flowCore::flowFrames, scatter fluorescent channels x1 selected; x1 x2 provided expression matrices, colnames x1 selected. binSize size equal bins approximate marginal distributions. minRange minimum value taken approximating marginal distributions maxRange maximum value taken approximating marginal distributions returnAll TRUE, distributions marginal distribution distances returned well. Default = FALSE.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/EMDDist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Earth Mover's distance between two samples — EMDDist","text":"Earth Mover's distance x1 x2, calculated summing EMD approximates marginal distributions channel","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/EMDDist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Earth Mover's distance between two samples — EMDDist","text":"","code":"library(CytoPipeline) #>  #> Attaching package: ‘CytoPipeline’ #> The following objects are masked from ‘package:Biobase’: #>  #>     pData, pData<-  data(OMIP021Samples)  # estimate scale transformations  # and transform the whole OMIP021Samples  transList <- estimateScaleTransforms(     ff = OMIP021Samples[[1]],     fluoMethod = \"estimateLogicle\",     scatterMethod = \"linearQuantile\",     scatterRefMarker = \"BV785 - CD3\")  OMIP021Trans <- CytoPipeline::applyScaleTransforms(     OMIP021Samples,      transList)  # distance with itself (all channels at once) # => should return 0 dist0 <- EMDDist(     x1 = OMIP021Trans[[1]],     x2 = OMIP021Trans[[1]])  # returning only distance, 2 channels dist1 <- EMDDist(     x1 = OMIP021Trans[[1]],      x2 = OMIP021Trans[[2]],      channels = c(\"FSC-A\", \"SSC-A\"))  # using only one channel, passed by marker name dist2 <- EMDDist(x1 = OMIP021Trans[[1]],                   x2 = OMIP021Trans[[2]],                   channels = c(\"BV785 - CD3\"))  # using only one channel, passed by index dist3 <- EMDDist(x1 = OMIP021Trans[[1]],                   x2 = OMIP021Trans[[2]],                   channels = 10)  dist2 == dist3 #> [1] TRUE"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/MDS.html","id":null,"dir":"Reference","previous_headings":"","what":"MDS class — MDS-class","title":"MDS class — MDS-class","text":"Class representing Multi Dimensional Scaling (MDS) projection. returns value stress criterion, minimized SMACOF algorithm. returns vector nPoints dimension, containing stress indicator per point. stress minimization criterion can indeed allocated per represented point. stress particular point, less accurate distances w.r.t. points.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/MDS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MDS class — MDS-class","text":"","code":"# S4 method for class 'MDS' show(object)  nDim(x)  nPoints(x)  pwDist(x)  projections(x)  projDist(x)  stress(x)  spp(x)  eigenVals(x)  pctvar(x)  RSq(x)  RSqVec(x)  GoF(x)  smacofRes(x)"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/MDS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MDS class — MDS-class","text":"object MDS object x MDS object","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/MDS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MDS class — MDS-class","text":"nothing","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/MDS.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"MDS class — MDS-class","text":"nDim numeric, nb dimensions projection pwDist object class dist storing triangular relevant part symmetric, zero diagonal pairwise distance matrix (nPoints * nPoints), projection. proj projection matrix, resulting MDS projDist object class dist storing triangular relevant part symmetric, zero diagonal pairwise distance matrix (nPoints * nPoints), projection. eigen numeric, vector nDim length, containing eigen values PCA applied Smacof algorithm. pctvar numeric, vector nDim length, containing percentage explained variance per axis. RSq numeric, vector pseudo R square indicators, function number dimensions. RSq[nDim] global pseudo R square, displayed plots. GoF numeric, vector goodness fit indicators, function number dimensions. GoF[nDim] global goodness fit. Note pseudo R square goodness fit indicators essentially indicator, definition total sum squares differ: pseudo RSq: TSS calculated using mean pairwise distance minimum goodness fit: TSS calculated using 0 minimum smacofRes object class 'smacofB' containing algorithmic optimization results, example stress stress per point, returned smacof::smacofSym() method.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/MDS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"MDS class — MDS-class","text":"","code":"nHD <- 10 nLD <- 2 nPoints <- 20   # generate uniformly distributed points in 10 dimensions points <- matrix(     data = runif(n = nPoints * nHD),     nrow = nPoints)      # calculate euclidian distances      pwDist  <- dist(points)  # compute Metric MDS object by reaching a target pseudo RSquare mdsObj <- computeMetricMDS(pwDist, targetPseudoRSq = 0.95)  show(mdsObj) #> MDS object containing MDS projection (using Smacof algorithm)  data: #> Nb of dimensions:  7  #> Nb of points:  20  #> Stress:  0.028101  #> Pseudo RSquare:  0.97695  #> Goodness of fit:  0.99921"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/channelSummaryStats.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary statistics per channel computation — channelSummaryStats","title":"Summary statistics per channel computation — channelSummaryStats","text":"Computation summary statistic selected channels, flowFrames flowSet, expression matrices list. method provides three different input modes: user provides directly flowCore::flowSet loaded memory (RAM) user provides directly list expression matrices column names channel/marker names user provides (1.) number samples nSamples; (2.) ad-hoc function takes input index 1 nSamples, codes method load corresponding expression matrix memory;","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/channelSummaryStats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary statistics per channel computation — channelSummaryStats","text":"","code":"channelSummaryStats(   x,   loadExprMatrixFUN = NULL,   loadExprMatrixFUNArgs = NULL,   channels = NULL,   statFUNs = stats::median,   verbose = FALSE,   BPPARAM = BiocParallel::SerialParam(),   BPOPTIONS = BiocParallel::bpoptions(packages = c(\"flowCore\")) )"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/channelSummaryStats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary statistics per channel computation — channelSummaryStats","text":"x can : flowCore::flowSet list expression matrices (Double matrix named columns) number samples (integer >=1) loadExprMatrixFUN function used translate integer index expression matrix. words, function code load indexth expression matrix memory. IMPORTANT: expression matrix index first function argument named exprMatrixIndex. loadExprMatrixFUNArgs (optional) named list containing additional input parameters loadExprMatrixFUN() channels channels needs included: character vector, can refer either channel names, marker names numeric vector, refers indices channels fs NULL, scatter fluorescent channels fs #' selected. statFUNs list (possibly length one) functions call calculate statistics, simple function. list can named, case, names transfered returned list. verbose TRUE, output message single statistics calculation BPPARAM sets BPPARAM back-end used computation. provided, use BiocParallel::SerialParam() (task parallelization) BPOPTIONS sets BPOPTIONS passed bplapply() function. Note use SnowParams back-end, need specify packages need loaded different CytoProcessingStep work properly (visibility functions). minimum, flowCore package needs loaded. (hence default BPOPTIONS = bpoptions(packages = c(\"flowCore\")) )","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/channelSummaryStats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary statistics per channel computation — channelSummaryStats","text":"list named statistic matrices. stat matrix, columns channel statistics flowFrames flowSet. Exception: one stat function (list) passed statFUNs, return value simplified stat matrix .","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/channelSummaryStats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary statistics per channel computation — channelSummaryStats","text":"","code":"library(CytoPipeline)  data(OMIP021Samples)  # estimate scale transformations  # and transform the whole OMIP021Samples  transList <- estimateScaleTransforms(     ff = OMIP021Samples[[1]],     fluoMethod = \"estimateLogicle\",     scatterMethod = \"linearQuantile\",     scatterRefMarker = \"BV785 - CD3\")  OMIP021Trans <- CytoPipeline::applyScaleTransforms(     OMIP021Samples,      transList)  channelsOrMarkers <- c(\"FSC-A\", \"SSC-A\", \"BV785 - CD3\")  # calculate mean for each 4 selected channels, for each 2 samples  channelMeans <- channelSummaryStats(     OMIP021Trans,     channels = channelsOrMarkers,     statFUNs = mean)      # calculate median AND std deviation # for each 4 selected channels, for each 2 samples  channelMedians <- channelSummaryStats(     OMIP021Trans,     channels = channelsOrMarkers,     statFUNs = list(\"median\" = stats::median,                      \"std.dev\" = stats::sd))"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/computeMetricMDS.html","id":null,"dir":"Reference","previous_headings":"","what":"metric MDS projection of sample — computeMetricMDS","title":"metric MDS projection of sample — computeMetricMDS","text":"Multi-dimensional scaling projection samples, using distance matrix input. MDS algorithm classical MDS (cmdscale alike, aka Torgerson's algorithm), SMACOF algorithm metric distances necessarily euclidean. obtained projections nDim dimensions, always apply svd decomposition visualize first axes ones contain variance projected dataset nDim dimensions. Instead provided directly user, nDim parameter can otherwise found iteratively finding minimum nDim parameter allows projection reach target pseudo RSquare. case, maxDim parameter used avoid looking big projection spaces.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/computeMetricMDS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"metric MDS projection of sample — computeMetricMDS","text":"","code":"computeMetricMDS(   pwDist,   whichChannels = NULL,   nDim = NULL,   seed = NULL,   targetPseudoRSq = 0.95,   maxDim = 128,   ... )"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/computeMetricMDS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"metric MDS projection of sample — computeMetricMDS","text":"pwDist (nSamples rows, nSamples columns), previously calculated pairwise distances samples, can provided : DistSum object dist object full symmetric square matrix, 0. diagonal whichChannels pwDist provided DistSum object, vector channels included distances. case distances computed sum unidimensional distances channel, DistSum object allows restrict channel sets included distance accounting nDim number dimensions projection, input SMACOF algorithm provided, found iteratively using targetPseudoRSq seed seed set launching SMACOF algorithm (e.g. init set \"random\" ) targetPseudoRSq target pseudo RSquare reached (used nDim set NULL) maxDim case nDim found iteratively, maximum number dimensions search procedure allowed explore ... additional parameters passed SMACOF algorithm","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/computeMetricMDS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"metric MDS projection of sample — computeMetricMDS","text":"object S4 class MDS","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/computeMetricMDS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"metric MDS projection of sample — computeMetricMDS","text":"","code":"library(CytoPipeline)  data(OMIP021Samples)  # estimate scale transformations  # and transform the whole OMIP021Samples  transList <- estimateScaleTransforms(     ff = OMIP021Samples[[1]],     fluoMethod = \"estimateLogicle\",     scatterMethod = \"linearQuantile\",     scatterRefMarker = \"BV785 - CD3\")  OMIP021Trans <- CytoPipeline::applyScaleTransforms(     OMIP021Samples,      transList)      # As there are only 2 samples in OMIP021Samples dataset, # we create artificial samples that are random combinations of both samples  ffList <- c(     flowCore::flowSet_to_list(OMIP021Trans),     lapply(3:5,            FUN = function(i) {                aggregateAndSample(                    OMIP021Trans,                    seed = 10*i,                    nTotalEvents = 5000)[,1:22]            }))  fsNames <- c(\"Donor1\", \"Donor2\", paste0(\"Agg\",1:3)) names(ffList) <- fsNames  fsAll <- as(ffList,\"flowSet\")  flowCore::pData(fsAll)$type <- factor(c(\"real\", \"real\", rep(\"synthetic\", 3))) flowCore::pData(fsAll)$grpId <- factor(c(\"D1\", \"D2\", rep(\"Agg\", 3)))  # calculate all pairwise distances  pwDist <- pairwiseEMDDist(fsAll,                               channels = c(\"FSC-A\", \"SSC-A\"),                              verbose = FALSE)  # compute Metric MDS object with explicit number of dimensions mdsObj <- computeMetricMDS(pwDist, nDim = 4, seed = 0)  dim <- nDim(mdsObj) # should be 4  #' # compute Metric MDS object by reaching a target pseudo RSquare mdsObj2 <- computeMetricMDS(pwDist, seed = 0, targetPseudoRSq = 0.999)"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotDistFeatureImportance.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of feature relative importance in distance — ggplotDistFeatureImportance","title":"Plot of feature relative importance in distance — ggplotDistFeatureImportance","text":"ggplotDistFeatureImportance uses ggplot2 provide stacked bar plot feature importance distance matrix.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotDistFeatureImportance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of feature relative importance in distance — ggplotDistFeatureImportance","text":"","code":"ggplotDistFeatureImportance(distObj)"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotDistFeatureImportance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of feature relative importance in distance — ggplotDistFeatureImportance","text":"distObj DistSum object.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotDistFeatureImportance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of feature relative importance in distance — ggplotDistFeatureImportance","text":"ggplot object","code":""},{"path":[]},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotDistFeatureImportance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of feature relative importance in distance — ggplotDistFeatureImportance","text":"","code":"library(CytoPipeline)  data(OMIP021Samples)  # estimate scale transformations  # and transform the whole OMIP021Samples  transList <- estimateScaleTransforms(     ff = OMIP021Samples[[1]],     fluoMethod = \"estimateLogicle\",     scatterMethod = \"linearQuantile\",     scatterRefMarker = \"BV785 - CD3\")  OMIP021Trans <- CytoPipeline::applyScaleTransforms(     OMIP021Samples,      transList)  # As there are only 2 samples in OMIP021Samples dataset, # we create artificial samples that are random combinations of both samples  ffList <- c(     flowCore::flowSet_to_list(OMIP021Trans),     lapply(3:5,            FUN = function(i) {                aggregateAndSample(                    OMIP021Trans,                    seed = 10*i,                    nTotalEvents = 5000)[,1:22]            }))  fsNames <- c(\"Donor1\", \"Donor2\", paste0(\"Agg\",1:3)) names(ffList) <- fsNames  fsAll <- as(ffList,\"flowSet\")  flowCore::pData(fsAll)$type <- factor(c(\"real\", \"real\", rep(\"synthetic\", 3))) flowCore::pData(fsAll)$grpId <- factor(c(\"D1\", \"D2\", rep(\"Agg\", 3)))  # calculate all pairwise distances  pwDist <- pairwiseEMDDist(fsAll,                               channels = c(\"FSC-A\", \"SSC-A\"),                              verbose = FALSE)                               p <- ggplotDistFeatureImportance(pwDist)"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotMarginalDensities.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of channel intensity marginal densities — ggplotMarginalDensities","title":"Plot of channel intensity marginal densities — ggplotMarginalDensities","text":"ggplotMarginalDensities uses ggplot2 draw plots marginal densities selected channels flowSet. flowSet contains several flowFrames, events concatenated together. default, pseudo Rsquare projection quality indicator, number dimensions MDS projection provided sub-title","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotMarginalDensities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of channel intensity marginal densities — ggplotMarginalDensities","text":"","code":"ggplotMarginalDensities(   x,   sampleSubset,   channels,   pDataForColour,   pDataForGroup,   nEventInSubsample = Inf,   seed = NULL,   transList )"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotMarginalDensities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of channel intensity marginal densities — ggplotMarginalDensities","text":"x flowCore::flowSet (single flowCore::flowFrame) sampleSubset (optional) logical vector, size nrow(pData), construction nb samples, indicating samples keep plot. Typically obtained evaluation logical condition pData rows. channels (optional) pDataForColour (optional) phenoData(fs) variable used colour aesthetic. character. pDataForGroup (optional) phenoData(fs) variable used group aesthetic. character. nEventInSubsample many event take (per flowFrame flowSet). seed null, used subsampling. transList flowCore::transformList applied plotting.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotMarginalDensities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of channel intensity marginal densities — ggplotMarginalDensities","text":"ggplot object","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotMarginalDensities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of channel intensity marginal densities — ggplotMarginalDensities","text":"","code":"library(CytoPipeline)  data(OMIP021Samples)  # estimate scale transformations  # and transform the whole OMIP021Samples  transList <- estimateScaleTransforms(     ff = OMIP021Samples[[1]],     fluoMethod = \"estimateLogicle\",     scatterMethod = \"linearQuantile\",     scatterRefMarker = \"BV785 - CD3\")  OMIP021Trans <- CytoPipeline::applyScaleTransforms(     OMIP021Samples,      transList)       # As there are only 2 samples in OMIP021Samples dataset, # we create artificial samples that are random combinations of both samples  ffList <- c(     flowCore::flowSet_to_list(OMIP021Trans),     lapply(3:5,            FUN = function(i) {                aggregateAndSample(                    OMIP021Trans,                    seed = 10*i,                    nTotalEvents = 5000)[,1:22]            }))  fsNames <- c(\"Donor1\", \"Donor2\", paste0(\"Agg\",1:3)) names(ffList) <- fsNames  fsAll <- as(ffList,\"flowSet\")  flowCore::pData(fsAll)$grpId <- factor(c(\"D1\", \"D2\", rep(\"Agg\", 3))) flowCore::pData(fsAll)$lbl <- paste0(\"S\", 1:5)  # plot densities, all samples together p <- ggplotMarginalDensities(fsAll)  # plot densities, per sample p <- ggplotMarginalDensities(fsAll, pDataForGroup = \"lbl\")  # plot densities, per sample and coloured by group p <- ggplotMarginalDensities(     fsAll,      pDataForGroup = \"lbl\",     pDataForColour = \"grpId\")"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotSampleMDS.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of Metric MDS object — ggplotSampleMDS","title":"Plot of Metric MDS object — ggplotSampleMDS","text":"ggplotSampleMDS uses ggplot2 provide plots Metric MDS results. default, pseudo Rsquare projection quality indicator, number dimensions MDS projection provided sub-title","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotSampleMDS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of Metric MDS object — ggplotSampleMDS","text":"","code":"ggplotSampleMDS(   mdsObj,   pData,   sampleSubset,   projectionAxes = c(1, 2),   biplot = FALSE,   biplotType = c(\"correlation\", \"regression\"),   extVariables,   pDataForColour,   pDataForShape,   pDataForLabel,   pDataForAdditionalLabelling,   pointSize = 1,   pointSizeReflectingStress = FALSE,   title = \"Multi Dimensional Scaling\",   displayPointLabels = TRUE,   pointLabelSize = 3.88,   repelPointLabels = TRUE,   displayArrowLabels = TRUE,   arrowLabelSize = 3.88,   repelArrowLabels = FALSE,   arrowThreshold = 0.8,   flipXAxis = FALSE,   flipYAxis = FALSE,   displayPseudoRSq = TRUE,   ... )"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotSampleMDS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of Metric MDS object — ggplotSampleMDS","text":"mdsObj MDS object, output computeMetricMDS() method. pData (optional) data.frame providing user input sample data. can design experiment variables, phenotype data per sample,... used highlight sample categories plot /subsetting. sampleSubset (optional) logical vector, size nrow(pData), construction nb samples, indicating samples keep plot. Typically obtained evaluation logical condition pData rows. projectionAxes two axes plotted (numeric vector length 2) biplot TRUE, adds projection external variables biplotType type biplot used: \"correlation\", projection external variables according Pearson correlations w.r.t. projection axes (arrow x & y coordinates) \"regression\", linear regression external variables using 2 projection axes explanatory variables performed, projection external variables according regression coefficients (arrow direction) R square regression (arrow size) extVariables used generate biplot external variables used biplot. provided matrix named columns corresponding variables. number rows number samples. matrix might contain NA's, case complete rows used calculate biplot arrows. pDataForColour (optional) pData variable used colour aesthetic. character. pDataForShape (optional) pData variable used shape aesthetic. character. pDataForLabel (optional) pData variable used point labels plot. character. missing, point labels set equal point names defined MDS object (NULL, otherwise labels set). pDataForAdditionalLabelling (optional) pData variable(s) add ggplot mapping, make available plotly tooltipping. array character maximum length 3. Note works biplot=FALSE, biplots contain circle arrows currently supported ggplotly. pointSize size points plots - pointSizeReflectingStress FALSE. pointSizeReflectingStress TRUE, size points appear proportional stress point, .e. bigger sample point appears, less accurate representation (terms distances w.r.t. points) title title give plot displayPointLabels TRUE, displays labels attached points (see pDataForLabels setting label values) pointLabelSize size point labels (default: 3.88 geom_text()) repelPointLabels TRUE, uses ggrepel::geom_text_repel() instead ggplot2::geom_text() (try split labels overlap) points displayArrowLabels TRUE, displays arrows labels (biplot) arrowLabelSize size arrow labels (default: 3.88 geom_text()) repelArrowLabels TRUE, uses ggrepel::geom_text_repel() instead ggplot2::geom_text() arrows (biplot) arrowThreshold (biplot), arrows made barely visible length (absolute value) less threshold. flipXAxis TRUE, take opposite x values (provided might ease low dimensional projection comparisons) flipYAxis TRUE, take opposite y values (provided might ease low dimensional projection comparisons) displayPseudoRSq TRUE, display pseudo RSquare subtitle, top nb dimensions ... additional parameters passed ggrepel::geom_text_repel() (used)","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotSampleMDS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of Metric MDS object — ggplotSampleMDS","text":"ggplot object","code":""},{"path":[]},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotSampleMDS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of Metric MDS object — ggplotSampleMDS","text":"","code":"library(CytoPipeline)  data(OMIP021Samples)  # estimate scale transformations  # and transform the whole OMIP021Samples  transList <- estimateScaleTransforms(     ff = OMIP021Samples[[1]],     fluoMethod = \"estimateLogicle\",     scatterMethod = \"linearQuantile\",     scatterRefMarker = \"BV785 - CD3\")  OMIP021Trans <- CytoPipeline::applyScaleTransforms(     OMIP021Samples,      transList)  # As there are only 2 samples in OMIP021Samples dataset, # we create artificial samples that are random combinations of both samples  ffList <- c(     flowCore::flowSet_to_list(OMIP021Trans),     lapply(3:5,            FUN = function(i) {                aggregateAndSample(                    OMIP021Trans,                    seed = 10*i,                    nTotalEvents = 5000)[,1:22]            }))  fsNames <- c(\"Donor1\", \"Donor2\", paste0(\"Agg\",1:3)) names(ffList) <- fsNames  fsAll <- as(ffList,\"flowSet\")  flowCore::pData(fsAll)$type <- factor(c(\"real\", \"real\", rep(\"synthetic\", 3))) flowCore::pData(fsAll)$grpId <- factor(c(\"D1\", \"D2\", rep(\"Agg\", 3)))  # calculate all pairwise distances  pwDist <- pairwiseEMDDist(fsAll,                               channels = c(\"FSC-A\", \"SSC-A\"),                              verbose = FALSE)  # compute Metric MDS object with explicit number of dimensions mdsObj <- computeMetricMDS(pwDist, nDim = 4, seed = 0)  dim <- nDim(mdsObj) # should be 4  #' # compute Metric MDS object by reaching a target pseudo RSquare mdsObj2 <- computeMetricMDS(pwDist, seed = 0, targetPseudoRSq = 0.999)    # plot mds projection on axes 1 and 2, # use 'grpId' for colour, 'type' for shape, and no label   p_12 <- ggplotSampleMDS(     mdsObj = mdsObj,     pData = flowCore::pData(fsAll),     projectionAxes = c(1,2),     pDataForColour = \"grpId\",     pDataForShape = \"type\")  # plot mds projection on axes 3 and 4, # use 'grpId' for colour, and 'name' as point label  p_34 <- ggplotSampleMDS(     mdsObj = mdsObj,     pData = flowCore::pData(fsAll),     projectionAxes = c(3,4),     pDataForColour = \"grpId\",     pDataForLabel = \"name\")  # plot mds projection on axes 1 and 2, # use 'group' for colour, 'type' for shape, and 'name' as point label # have sample point size reflecting 'stress' # i.e. quality of projection w.r.t. distances to other points  p12_Stress <- ggplotSampleMDS(     mdsObj = mdsObj,     pData = flowCore::pData(fsAll),     projectionAxes = c(1,2),     pDataForColour = \"grpId\",     pDataForLabel = \"name\",     pDataForShape = \"type\",     pointSizeReflectingStress = TRUE)  # try to associate axes with median of each channel # => use bi-plot  extVars <- channelSummaryStats(     fsAll,     channels = c(\"FSC-A\", \"SSC-A\"),     statFUNs = stats::median)   bp_12 <- ggplotSampleMDS(     mdsObj = mdsObj,     pData = flowCore::pData(fsAll),     projectionAxes = c(1,2),     biplot = TRUE,     extVariables = extVars,     pDataForColour = \"grpId\",     pDataForShape = \"type\",     seed = 0)  bp_34 <- ggplotSampleMDS(     mdsObj = mdsObj,     pData = flowCore::pData(fsAll),     projectionAxes = c(3,4),     biplot = TRUE,     extVariables = extVars,     pDataForColour = \"grpId\",     pDataForLabel = \"name\",     seed = 0)"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotSampleMDSShepard.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of Metric MDS object - Shepard diagram — ggplotSampleMDSShepard","title":"Plot of Metric MDS object - Shepard diagram — ggplotSampleMDSShepard","text":"ggplotSampleMDSShepard uses ggplot2 provide plot Metric MDS results. Shepard diagram provides scatter plot : x axis, high dimensional pairwise distances sample pairs y axis, corresponding pairwise distances obtained low dimensional projection","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotSampleMDSShepard.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of Metric MDS object - Shepard diagram — ggplotSampleMDSShepard","text":"","code":"ggplotSampleMDSShepard(   mdsObj,   nDim,   title = \"Multi Dimensional Scaling - Shepard's diagram\",   pointSize = 0.5,   lineWidth = 0.5,   displayPseudoRSq = TRUE )"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotSampleMDSShepard.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of Metric MDS object - Shepard diagram — ggplotSampleMDSShepard","text":"mdsObj MDS object, output computeMetricMDS() method. nDim (optional) number dimensions use calculating Shepard's diagram pseudoRSquare. missing, set equal number projection dimensions calculated mdsObj title title give plot pointSize point size plot lineWidth line width plot displayPseudoRSq TRUE, display pseudo RSquare subtitle, top nb dimensions","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotSampleMDSShepard.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of Metric MDS object - Shepard diagram — ggplotSampleMDSShepard","text":"ggplot object","code":""},{"path":[]},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotSampleMDSShepard.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of Metric MDS object - Shepard diagram — ggplotSampleMDSShepard","text":"","code":"library(CytoPipeline)  data(OMIP021Samples)  # estimate scale transformations  # and transform the whole OMIP021Samples  transList <- estimateScaleTransforms(     ff = OMIP021Samples[[1]],     fluoMethod = \"estimateLogicle\",     scatterMethod = \"linearQuantile\",     scatterRefMarker = \"BV785 - CD3\")  OMIP021Trans <- CytoPipeline::applyScaleTransforms(     OMIP021Samples,      transList)      ffList <- c(     flowCore::flowSet_to_list(OMIP021Trans),     lapply(3:5,            FUN = function(i) {                aggregateAndSample(                    OMIP021Trans,                    seed = 10*i,                    nTotalEvents = 5000)[,1:22]            }))  fsNames <- c(\"Donor1\", \"Donor2\", paste0(\"Agg\",1:3)) names(ffList) <- fsNames  fsAll <- as(ffList,\"flowSet\")  flowCore::pData(fsAll)$type <- factor(c(\"real\", \"real\", rep(\"synthetic\", 3))) flowCore::pData(fsAll)$grpId <- factor(c(\"D1\", \"D2\", rep(\"Agg\", 3)))  # calculate all pairwise distances  pwDist <- pairwiseEMDDist(fsAll,                               channels = c(\"FSC-A\", \"SSC-A\"),                              verbose = FALSE)  # compute Metric MDS object with explicit number of dimensions mdsObj <- computeMetricMDS(pwDist, nDim = 4, seed = 0)  dim <- nDim(mdsObj) # should be 4  #' # compute Metric MDS object by reaching a target pseudo RSquare mdsObj2 <- computeMetricMDS(pwDist, seed = 0, targetPseudoRSq = 0.999)  # Shepard diagrams   p2D <- ggplotSampleMDSShepard(     mdsObj,     nDim = 2,     pointSize = 1,     title = \"Shepard with 2 dimensions\")  p3D <- ggplotSampleMDSShepard(     mdsObj,     nDim = 3,     title = \"Shepard with 3 dimensions\")      #'  pDefD <- ggplotSampleMDSShepard(     mdsObj,     title = \"Shepard with default nb of dimensions\")"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotSampleMDSWrapBiplots.html","id":null,"dir":"Reference","previous_headings":"","what":"SampleMDS biplot wrapping — ggplotSampleMDSWrapBiplots","title":"SampleMDS biplot wrapping — ggplotSampleMDSWrapBiplots","text":"ggplotSampleMDSWrapBiplots calls ggplotSampleMDS repeatly generate biplots different sets external variables align grid using patchwork package, similar fashion ggplot2::facet_wrap() .","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotSampleMDSWrapBiplots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SampleMDS biplot wrapping — ggplotSampleMDSWrapBiplots","text":"","code":"ggplotSampleMDSWrapBiplots(   mdsObj,   extVariableList,   ncol = NULL,   nrow = NULL,   byrow = NULL,   displayLegend = TRUE,   ... )"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotSampleMDSWrapBiplots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SampleMDS biplot wrapping — ggplotSampleMDSWrapBiplots","text":"mdsObj MDS object, output computeMetricMDS() method extVariableList named list external variable matrices element list matrix named columns corresponding variables. number rows number samples. ncol passed patchwork::wrap_plots() nrow passed patchwork::wrap_plots() byrow passed patchwork::wrap_plots() displayLegend FALSE, de-active legend display ... additional parameters passed ggplotSampleMDS() (used)","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotSampleMDSWrapBiplots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SampleMDS biplot wrapping — ggplotSampleMDSWrapBiplots","text":"ggplot object","code":""},{"path":[]},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/ggplotSampleMDSWrapBiplots.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SampleMDS biplot wrapping — ggplotSampleMDSWrapBiplots","text":"","code":"library(CytoPipeline)  data(OMIP021Samples)  # estimate scale transformations  # and transform the whole OMIP021Samples  transList <- estimateScaleTransforms(     ff = OMIP021Samples[[1]],     fluoMethod = \"estimateLogicle\",     scatterMethod = \"linearQuantile\",     scatterRefMarker = \"BV785 - CD3\")  OMIP021Trans <- CytoPipeline::applyScaleTransforms(     OMIP021Samples,      transList)      # As there are only 2 samples in OMIP021Samples dataset, # we create artificial samples that are random combinations of both samples  ffList <- c(     flowCore::flowSet_to_list(OMIP021Trans),     lapply(3:5,            FUN = function(i) {                aggregateAndSample(                    OMIP021Trans,                    seed = 10*i,                    nTotalEvents = 5000)[,1:22]            }))  fsNames <- c(\"Donor1\", \"Donor2\", paste0(\"Agg\",1:3)) names(ffList) <- fsNames  fsAll <- as(ffList,\"flowSet\")  flowCore::pData(fsAll)$type <- factor(c(\"real\", \"real\", rep(\"synthetic\", 3))) flowCore::pData(fsAll)$grpId <- factor(c(\"D1\", \"D2\", rep(\"Agg\", 3)))  # calculate all pairwise distances  pwDist <- pairwiseEMDDist(fsAll,                               channels = c(\"FSC-A\", \"SSC-A\"),                              verbose = FALSE)  # compute Metric MDS object with explicit number of dimensions mdsObj <- computeMetricMDS(pwDist, nDim = 4, seed = 0)  dim <- nDim(mdsObj) # should be 4  #' # compute Metric MDS object by reaching a target pseudo RSquare mdsObj2 <- computeMetricMDS(pwDist, seed = 0, targetPseudoRSq = 0.999)  # plot mds projection on axes 1 and 2, # use 'group' for colour, 'type' for shape, and no label   p_12 <- ggplotSampleMDS(     mdsObj = mdsObj,     pData = flowCore::pData(fsAll),     projectionAxes = c(1,2),     pDataForColour = \"grpId\",     pDataForShape = \"type\")  # try to associate axes with median or std deviation of each channel # => use bi-plots  extVarList <- channelSummaryStats(     fsAll,     channels = c(\"FSC-A\", \"SSC-A\"),     statFUNs = c(\"median\" = stats::median,                   \"std.dev\" = stats::sd))  bpFull <- ggplotSampleMDSWrapBiplots(     mdsObj = mdsObj,     extVariableList = extVarList,     pData = flowCore::pData(fsAll),     projectionAxes = c(1,2),     pDataForColour = \"group\",     pDataForShape = \"type\",     seed = 0)"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/pairwiseEMDDist.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise Earth Mover's Distance calculation — pairwiseEMDDist","title":"Pairwise Earth Mover's Distance calculation — pairwiseEMDDist","text":"Computation EMD pairs flowFrames belonging flowSet. method provides three different input modes: user provides directly flowCore::flowSet loaded memory (RAM). user provides directly list expression matrices loaded RAM, column names channel/marker names user provides (1.) number samples nSamples; (2.) ad-hoc function takes input index 1 nSamples, codes method load corresponding expression matrix memory; Optional row column ranges can provided limit calculation specific rectangle matrix. .e. can specified way split heavy calculations large distance matrices several computation nodes.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/pairwiseEMDDist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise Earth Mover's Distance calculation — pairwiseEMDDist","text":"","code":"pairwiseEMDDist(   x,   rowRange = c(1, nSamples),   colRange = c(min(rowRange), nSamples),   loadExprMatrixFUN = NULL,   loadExprMatrixFUNArgs = NULL,   channels = NULL,   verbose = FALSE,   BPPARAM = BiocParallel::SerialParam(),   BPOPTIONS = BiocParallel::bpoptions(packages = c(\"flowCore\")),   binSize = 0.05,   minRange = -10,   maxRange = 10 )"},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/pairwiseEMDDist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise Earth Mover's Distance calculation — pairwiseEMDDist","text":"x can : flowCore::flowSet list expression matrices (Double matrix named columns) number samples (integer >=1) rowRange range rows distance matrix calculated colRange range columns distance matrix calculated loadExprMatrixFUN function used translate integer index expression matrix. words, function code load indexth expression matrix memory. IMPORTANT: expression matrix index first function argument named exprMatrixIndex. loadExprMatrixFUNArgs (optional) named list containing additional input parameters loadExprMatrixFUN() channels channels (integer index(ices) character(s)): character vector, can refer either channel names, marker names numeric vector, refers indexes channels fs NULL scatter fluorescent channels fs #' selected verbose TRUE, output message single distance calculation BPPARAM sets BPPARAM back-end used computation. provided, use BiocParallel::SerialParam() (task parallelization) BPOPTIONS sets BPOPTIONS passed bplapply() function. Note use SnowParams back-end, need specify packages need loaded different CytoProcessingStep work properly (visibility functions). minimum, flowCore package needs loaded. (hence default BPOPTIONS = bpoptions(packages = c(\"flowCore\")) ) binSize size equal bins approximate marginal distributions. minRange minimum value taken approximating marginal distributions maxRange maximum value taken approximating marginal distributions","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/pairwiseEMDDist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise Earth Mover's Distance calculation — pairwiseEMDDist","text":"distance matrix pairwise distances (full symmetric 0. diagonal)","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/reference/pairwiseEMDDist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise Earth Mover's Distance calculation — pairwiseEMDDist","text":"","code":"library(CytoPipeline)  data(OMIP021Samples)  # estimate scale transformations # and transform the whole OMIP021Samples  transList <- estimateScaleTransforms(     ff = OMIP021Samples[[1]],     fluoMethod = \"estimateLogicle\",     scatterMethod = \"linearQuantile\",     scatterRefMarker = \"BV785 - CD3\")  OMIP021Trans <- CytoPipeline::applyScaleTransforms(     OMIP021Samples,     transList)  # calculate pairwise distances using only FSC-A & SSC-A channels pwDist <- pairwiseEMDDist(     x = OMIP021Trans,     channels = c(\"FSC-A\", \"SSC-A\"))"},{"path":[]},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-1-3","dir":"Changelog","previous_headings":"","what":"CytoMDS 1.3.3","title":"CytoMDS 1.3","text":"DistSum class store distance matrices computed sum marker contributions ggplotDistDeatureImportance() now can used create stacked bar ggplot object, displaying feature importance distance matrix (extracted DistSum object)","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-1-3-1","dir":"Changelog","previous_headings":"","what":"CytoMDS 1.3.2","title":"CytoMDS 1.3","text":"added pointSize argument ggplotSampleMDS()","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-1-3-2","dir":"Changelog","previous_headings":"","what":"CytoMDS 1.3.1","title":"CytoMDS 1.3","text":"corrected bug nPoints() method MDS class, due slightly modified behaviour dist S3 class R4.5.","code":""},{"path":[]},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-1-1","dir":"Changelog","previous_headings":"","what":"CytoMDS 1.1.4","title":"CytoMDS 1.1","text":"implemented pkgdown customization","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds--1-1","dir":"Changelog","previous_headings":"","what":"CytoMDS 1.1.2 & 1.1.3","title":"CytoMDS 1.1","text":"expression matrices input EMD calculation","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-1-1-1","dir":"Changelog","previous_headings":"","what":"CytoMDS 1.1.1","title":"CytoMDS 1.1","text":"added citation bioRxiv pre-print","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-100","dir":"Changelog","previous_headings":"","what":"CytoMDS 1.0.0","title":"CytoMDS 1.0.0","text":"(release Bioconductor)","code":""},{"path":[]},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.16","title":"CytoMDS 0.99","text":"added lineWidth parameter ggplotSampleMDSShepard() running plotly::ggplotly() ggplotSampleMDSShepard() output now displays row column number distance point. added pointLabelSize arrowLabelSize ggplotSample()","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99-1","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.15","title":"CytoMDS 0.99","text":"corrected bug fix (error message) pwDist() verbose=TRUE","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99-2","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.14","title":"CytoMDS 0.99","text":"re-factored code portions replace, much possible, loops apply() family functions.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99-3","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.13","title":"CytoMDS 0.99","text":"re-factored code portions avoid growing lists incrementally","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99-4","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.12","title":"CytoMDS 0.99","text":"removed useBiocParallel parameters various stats functions (use BPPARAM = BiocParallel::SerialParam() default) implemented MDS class store MDS projection results bi-plots now explicitly discard constant external variables (+warning) instead raising error without producing plot implemented ggplotMarginalDensities() updated vignette Bodenmiller2012 dataset biological interpretation.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99-5","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.11","title":"CytoMDS 0.99","text":"re-factored package documentation file","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99-6","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.10","title":"CytoMDS 0.99","text":"biplot now handles extVariables missing values","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99-7","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.9","title":"CytoMDS 0.99","text":"ggplotSampleMDS() : add label layer geom_point() ()","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99-8","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.8","title":"CytoMDS 0.99","text":"renamed getChannelSummaryStats() channelSummaryStats() channelSummaryStats(), added support forBiocParallel`, allowed loading whole flowSet memory . replaced NULL defaulted parameters optional parameters added displayPointLabels argument ggplotSampleMDS() added displayLegend argument ggplotSampleMDSWrapBiplots() finalized creating vignette","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99-9","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.7","title":"CytoMDS 0.99","text":"refactored pairwise distance calculation code, pre-computing unidimensional histograms store instead recalculating time distance 2 samples calculated. improves CPU time memory consumption.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99-10","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.6","title":"CytoMDS 0.99","text":"added subset argument ggplotSampleMDS() ggplotSampleMDSWrapBiplots","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99-11","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.5","title":"CytoMDS 0.99","text":"renamed getPairwiseEMDDist() pairwiseEMDDist() pairwiseEMDDist(), added support BiocParallel, allowed loading whole flowSet memory .","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99-12","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.4","title":"CytoMDS 0.99","text":"getPairwiseEMDDist(), added second flowSet argument. two flowSet arguments non-null, distances calculated sample pairs, first element comes fs, second element comes fs2. renamed ggplotSamplesMDS ggplotSampleMDS renamed ggplotSamplesMDSShepard ggplotSampleMDSShepard renamed getChannelsSummaryStat getChannelSummaryStats new function ggplotSampleMDSWrapBiplots()","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99-13","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.3","title":"CytoMDS 0.99","text":"new version computeMetricMDS() automatically sets number dimensions reach target pseudo R squared added ggplotly() functionality output MDS plots ggplotSampleMDS(), added flipXAxis, flipYAxis possibly ease low dimensional projection comparisons ggplotSampleMDS(), added displayArrowLabels discard arrow labels biplot. Also added arrowThreshold. Moved arrow labels toward end arrows. ggplotSampleMDS() ggplotSampleMDSShepard(): added displayPseudoRSq parameter.","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99-14","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.2","title":"CytoMDS 0.99","text":"use global Rsquare indicator quality projection use %Var explained per axis","code":""},{"path":"https://uclouvain-cbio.github.io/CytoMDS/news/index.html","id":"cytomds-0-99-15","dir":"Changelog","previous_headings":"","what":"CytoMDS 0.99.1","title":"CytoMDS 0.99","text":"ggplotSamplesMDS(), added parameter pDataForAdditionalLabelling","code":""}]
